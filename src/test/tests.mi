include "includes/util" as util;

// ============================================================
// Helpers
// ============================================================

func _increment(a:int) -> int
{
  return a + 1;
}

func _decrement(a:int) -> int
{
  return a - 1;
}

func _dispatch(a:int, b:int, callback:func(int)->int) -> int
{
  return callback(a + b);
}

// ============================================================
// Tests
// ============================================================

func test_module_acess()
{
  util::assert_eq(util::pi, 3.14150, "module: read util::pi");
  util::pi = 42;
  util::assert_eq(util::pi, 42, "module: override util::pi");
  util::assert_eq(util::sum(6, 4), 10, "module: call util::sum(6,4)");
}

func test_list()
{
  // --- empty list ---
  let a = [];
  util::assert_eq(len(a), 0, "list: len([])");

  // --- literal + read ---
  let b = [10, 20, 30, ];
  util::assert_eq(b[0], 10, "list: b[0]");
  util::assert_eq(b[1], 20, "list: b[1]");
  util::assert_eq(b[2], 30, "list: b[2]");

  // --- computed index read ---
  let i = 1;
  util::assert_eq(b[i], 20, "list: b[i] (i=1)");

  // --- write ---
  b[1] = 99;
  util::assert_eq(b[1], 99, "list: b[1] after write");

  // --- write using expression index ---
  b[0 + 2] = 77;
  util::assert_eq(b[2], 77, "list: b[2] after write via expr index");

  // --- nested indexing (list of lists) ---
  let c = [[1, 2], [3, 4]];
  util::assert_eq(c[0][0], 1, "list: c[0][0]");
  util::assert_eq(c[0][1], 2, "list: c[0][1]");
  util::assert_eq(c[1][0], 3, "list: c[1][0]");
  util::assert_eq(c[1][1], 4, "list: c[1][1]");

  // --- write through nested indexing ---
  c[1][0] = 123;
  util::assert_eq(c[1][0], 123, "list: c[1][0] after nested write");

  // --- prove empty list literal is accepted as expression ---
  let d = [];
  // push(d, 42);
  // assert_eq(d[0], 42, "list: push into empty list");
}

func test_dict()
{
  // NOTE: d and y are currently assigned without 'let'.
  // If your language semantics create variables on assignment, this can leak across tests.
  // Keeping as-is; organization only.

  // empty dict
  d = [:];
  util::assert_eq(d != void, true, "dict: empty dict created");

  // literal initialization
  // NOTE: you have "b"=2 here (equals) while the rest uses ":".
  d = ["a":1, "b":2, "c":3, true:42, 7:"bob"];
  util::assert_eq(d["a"], 1, "dict: literal a");
  util::assert_eq(d["b"], 2, "dict: literal b");
  util::assert_eq(d["c"], 3, "dict: literal c");
  util::assert_eq(d[true], 42, "dict: literal true");
  util::assert_eq(d[7], "bob", "dict: literal 7");

  // overwrite existing key
  d["a"] = 10;
  util::assert_eq(d["a"], 10, "dict: overwrite key");

  // create new key via index assignment
  d["x"] = 42;
  util::assert_eq(d["x"], 42, "dict: create key via index");

  // nested usage (value reuse)
  y = d["a"] + d["b"];
  util::assert_eq(y, 12, "dict: read + arithmetic");
}

func test_foreach()
{
  // == foreach basic ==
  let xs = [1, 2, 3, 4];
  let sum = 0;

  foreach(x, xs)
  {
    sum = sum + x;
  }

  util::assert_eq(sum, 10, "foreach: basic sum");

  // == foreach nested ==
  let ys = [10, 20];
  let total = 0;

  foreach(a, xs)
  {
    foreach(b, ys)
    {
      total = total + a + b;
    }
  }

  util::assert_eq(total, 140, "foreach: nested total");


  // == foreach over literal ==
  let prod = 1;

  foreach(v, [2, 3, 4])
  {
    prod = prod * v;
  }

  util::assert_eq(prod, 24, "foreach: literal product");


  // == foreach with indexing ==
  let zs = [[1, 2], [3, 4], [5, 6]];
  let acc = 0;

  foreach(pair, zs)
  {
    acc = acc + pair[0] + pair[1];
  }

  util::assert_eq(acc, 21, "foreach: indexing");


  // == foreach shadowing ==
  let x = 100;

  foreach(x, [1, 2, 3])
  {
    let _ = x;
  }

  util::assert_eq(x, 100, "foreach: shadowing");


  // == foreach empty list ==
  let hit = false;

  foreach(v, [])
  {
    hit = true;
  }

  util::assert_eq(hit, false, "foreach: empty list");
}

func test_dynamic_functions()
{
  // NOTE: uses implicit vars l/sum in your original; keeping as-is would leak.
  // Here I'm only reorganizing; if you want, I can convert these to 'let' everywhere.

  l = [_increment, _decrement];
  sum = 0;

  foreach(n, l)
  {
    sum = sum + n(10);
  }

  util::assert_eq(sum, 20, "func: dynamic iteration");
}

func test_function_as_arg()
{
  result = _dispatch(25, 75, _increment);
  util::assert_eq(result, 101, "func: callback passed as arg");
}

// ============================================================
// Test runner
// ============================================================

tests = [
  test_module_acess,
  test_list,
  test_dict,
  test_foreach,
  test_dynamic_functions,
  test_function_as_arg
];

failures = 0;

foreach(f, tests)
{
  print("----", f, "----");
  f();
}
